



【基础】

【算法】
日志系统：
flume->kafka->hive->esearch->kibana



1. 进程、线程、协程？
进程：正在执⾏中的程序，是系统分配资源的基本单元，进程的创建、撤销、切换的开销⽐较
⼤；
线程：CPU执⾏的基本单元，⼀个进程⾄少有⼀个主线程。线程没有独⽴的系统资源，跟其它
线程共享进程的资源。对于某些独占资源存在锁机制。
协程：⽤户态的轻量级线程，完全由⽤户控制，协程不需要多线程的锁机制，在协程中控制共
享资源不加锁，只需要判断状态就好。
2. 为什么要⽤消息队列？
解耦：A系统要给BCD三个系统发送数据，如果是接⼜调⽤发送，后⾯如果再来个E系统
也需要相同数据，还得接⼜调⽤发送E。如果接收⽅挂了，还要考虑是否重发？
异步：A系统接收⼀个请求，需要本地写库，还需要在BCD三个系统写库，如果调接
⼜，就需要等BCD都写完了才能返回，这样响应速度太慢了，可以通过MQ异步处理。
削峰：系统在某点请求量巨⼤，但系统处理能⼒有限，可以通过MQ异步处理请求，进⾏
削峰。
3. 说说⽤消息队列都有什么优点和缺点？
优点：解耦、异步、削峰
缺点：
系统可⽤性降低：引⼊了MQ，如果MQ挂掉了，整个系统可能就挂掉了
系统复杂性提⾼：如何保证消息没有重复消费？怎么处理消息丢失？怎么保证消
息传递的顺序性？
⼀致性问题：A系统处理完以后就直接返回了，但BCD可能执⾏失败，导致数据不
⼀致。
4. kafka、activemq、rabbitmq、rocketmq都有什么区别？
单机吞吐量：Activemq、RabbitMQ万级，RocketMQ、Kafka⼗万级；
时效性：Activemq、RocketMQ、Kafka ms级，RabbitMQ微秒级；
可⽤性：ActiveMQ、RabbitMQ 基于主从架构实现⾼可⽤。RocketMQ，分布式架构，⾮
常⾼。Kafka也是分布式架构，⾼可⽤
消息可靠性：Activemq有较低概率丢失数据。rabbitmq基本不丢。rocketmq通过参数优化
配置，可做到0丢失。kafka同rocketmq
5. 如何保证消息队列的⾼可⽤啊？
RabbitMQ⾼可⽤性
三种模式：单机模式、普通集群模式、镜像集群模式
单机模式：只能⾃⼰玩，⽆⾼可⽤性；
普通集群模式：多台机器上启动多个rabbitmq实例，每个机器启动⼀个，但创建
的queue只会放在⼀个实例上，其他实例只是同步queue的元数据，⽆⾼可⽤性，
主要为了提⾼吞吐量。
镜像集群模式：会⾃动把消息到多个实例的queue⾥进⾏消息同步，⼀个宕机不影
响其他的
kafka⾼可⽤性
基本架构认识：多个broker组成，每个broker是⼀个节点；创建⼀个topic，这个
topic可以划分多个partition，每个partition可存在不同broker上，每个partition就放
⼀部分数据。
6. 如何保证消息不被重复消费啊？如何保证消费的时候是幂等的啊？
出现的原因：kafka有个offset，代表消息的序号，consumer消费数据后，每隔⼀段时间，
会把消费过的offset提交下，代表已经消费过。若已经消费了但还没来的及提交offset，重
启后就可能导致重复通知。解决⽅法需要结合业务具体分析。
⽅法1：先查库，看有没有处理过。。。。
⽅法2：使⽤redis，消息中加全局的id，类似订单id，消费过就放⼊redis，每次消费前先
查询下。
⽅法3：数据库唯⼀键保证不重复插⼊数据
7. 如何保证消息的可靠性传输啊？要是消息丢失了怎么办啊？
⽣产者丢失数据
Rabbitmq提供事务：失败则会重试，吞吐量会下降，太耗性能了。confirm模式：
每写⼊消息会分配⼀个唯⼀id，写⼊成功后会回传⼀个ack，若没处理这个消息，
会回调⼀个nack接⼜，告诉你这个消息接受失败，然后重发。事务机制是同步的
会堵塞，confirm机制是异步的。
kafka：关闭⾃动提交offset，处理完后每次⼿动提交offset，可能导致重复消费
mq丢失数据
rabbitmq可开启持久化。消息写⼊后会持久化到硬盘；
kafka：leader挂了，没同步数据，
消费端丢失数据
rabbitmq关闭⾃动ack，每次处理完后，在程序⾥ack，如果没处理完挂掉了，就没
有ack，rabbitmq会将消息分配给别的consumer去处理。
8. 那如何保证消息的顺序性？
rabbitmq：⼀个queue⼀个consumer。
kafka：⼀个topic，⼀个partition，⼀个consumer
9. 如果让你写⼀个消息队列，该如何进⾏架构设计啊？说⼀下你的思路
10. 为什么要⽤缓存？⾼性能、⾼并发
11. ⽤缓存后有啥不良后果？
缓存与数据库双写不⼀致
缓存雪崩
缓存穿透
缓存并发竞争
12. redis和memcached有啥区别？
redis⽀持更多的数据结构，memcached只有key-value
memcache没有持久化，redis有
13. 为何redis效率⾼？
存内存操作
核⼼是基于⾮阻塞的IO多路复⽤机制
单线程，避免多线程上下⽂切换。
14. redis如何key如何过期？
定期删除：随机抽取⼀些设置了过期时间的key，检查是否过期，过期则删除。
惰性删除：get这个key时，检查下是否过期，过期则直接删除。
15. 内存淘汰机制
定期删除和惰性删除可能都不能删除已经过期的key，如果⼤量过期key导致redis内存耗
尽。则⾛内存淘汰机制。
noeviction：当内存不⾜，不允许写⼊；
allkeys-lru：内存不⾜，在键空间移出最近最少使⽤的key
allkeys-random：内存不⾜，在键空间随机移出某个key
volatile-lru：在设置过期时间的键空间中，移出最近最少使⽤的key
volatile-random：在设置过期时间的键空间，随机移出某个key
volatile-ttl：在设置过期时间的键空间中，有更早过期时间的key优先移出。
16. redis雪崩和穿透？redis崩溃后怎么样，如何处理？
穿透：⼀些恶意请求故意查询不存在的key，导致⼤量请求落到后端服务器上。
对查询为空的情况也进⾏缓存，缓存时间设置短⼀点；
对⼀定不存在的key进⾏过滤，可以把所有的可能存在的key放在⼀个da的bitmap
中，查询时通过bitmap过滤
雪崩：⼤量缓存失效，导致请求落到后端服务器上，造成后端服务器的压⼒。
不同key，设置不同的过期时间，让缓存失效时间均匀⼀点。
缓存失效后，通过加锁或者队列来控制读取数据库；